---
name: gco-commit-conventions
description: Advanced commit scenarios for Ghost County - multi-requirement commits, work-in-progress tracking, breaking changes, and complex git operations. Use for complex commit scenarios beyond basic format. Triggers on "multi-requirement commit", "breaking change", "WIP commit", "complex commit", or advanced git questions.
---

# Commit Conventions - Advanced Scenarios

> **Note:** For basic commit format, see `.claude/rules/gco-commit-conventions.md`

This skill covers advanced commit scenarios beyond the standard single-requirement, complete-work commits.

## Work-in-Progress Commits

When work spans multiple sessions, track progress explicitly.

### Extended Format

```text
[REQ-XXX] Action: Brief description

What was done:
- Completed change 1
- Completed change 2

Next steps:
- What remains to be done
- Blocked items or dependencies

Status: IN_PROGRESS

 Generated with Claude Code
```

### Status Values

- **COMPLETE**: All acceptance criteria met, ready for review
- **IN_PROGRESS**: Work continues in next session
- **BLOCKED**: Cannot proceed without external change

### Rules

1. Use Status field ONLY when work is incomplete
2. "Next steps" section is REQUIRED for IN_PROGRESS or BLOCKED
3. Complete commits can omit both Status and Next steps
4. Never commit broken code - WIP commits should still pass tests

### Example: In-Progress Work

```text
[REQ-089] Fix: Authentication redirect loop

What was done:
- Identified root cause in middleware chain
- Updated auth middleware to check session state

Next steps:
- Add test coverage for redirect scenarios
- Verify fix across all protected routes

Status: IN_PROGRESS

 Generated with Claude Code
```

### Example: Blocked Work

```text
[REQ-101] Update: Payment processing to use new API

What was done:
- Reviewed new payment gateway documentation
- Drafted integration plan

Next steps:
- Cannot proceed: Waiting for staging API credentials
- Need security review of token storage approach

Status: BLOCKED

 Generated with Claude Code
```

## Multi-Requirement Commits

When a single commit touches multiple requirements (rare, but valid).

### Format

```text
[REQ-XXX, REQ-YYY] Action: Brief description

What was done:
- REQ-XXX: Specific change for first requirement
- REQ-YYY: Specific change for second requirement
- Shared: Changes affecting both

 Generated with Claude Code
```

### Rules

1. Only use when changes are TRULY interdependent
2. Maximum 2-3 requirements per commit
3. Prefix each bullet with REQ-XXX to show which requirement it satisfies
4. Must update roadmap for ALL referenced requirements

### Example

```text
[REQ-105, REQ-112] Refactor: Session startup protocol to use rules

What was done:
- REQ-105: Created .claude/rules/gco-session-startup.md with protocol
- REQ-112: Removed duplicated protocol from session-startup skill
- Shared: Verified protocol consistency between rule and skill reference

 Generated with Claude Code
```

### When NOT to Use Multi-Requirement

- Don't batch unrelated changes "for efficiency"
- Don't combine bug fixes with features
- Don't mix refactoring with new functionality

Make separate commits instead.

## Breaking Changes

Commits that break backward compatibility require special handling.

### Format

```text
[REQ-XXX] BREAKING: Brief description of what breaks

What was done:
- Changed API/interface detail
- Updated dependent code
- Documented migration path

BREAKING CHANGE:
Previous behavior: <what used to work>
New behavior: <what works now>
Migration: <how to update dependent code>

 Generated with Claude Code
```

### Rules

1. Use `BREAKING:` prefix in header (replaces normal Action verb)
2. Add `BREAKING CHANGE:` section before footer
3. Document migration path clearly
4. Update ALL dependent code in same commit
5. Notify team via PR description or chat

### Example

```text
[REQ-078] BREAKING: Rename getUser to fetchUserById

What was done:
- Renamed auth.getUser() to auth.fetchUserById()
- Updated all 23 call sites across 8 files
- Added deprecation notice to CHANGELOG.md

BREAKING CHANGE:
Previous behavior: auth.getUser(id) returned user object
New behavior: Use auth.fetchUserById(id) instead
Migration: Find/replace "getUser(" with "fetchUserById(" in your code

 Generated with Claude Code
```

## Merge Commits

When merging branches, follow specific conventions.

### Format (Auto-generated by Git)

```text
Merge branch 'feature/REQ-XXX' into main

[REQ-XXX] Merged: Brief description of feature

What was merged:
- Summary of feature changes
- Notable implementation details
- Test coverage added

 Generated with Claude Code
```

### Rules

1. Let git auto-generate the merge commit message
2. Add structured body following standard format
3. Summarize the ENTIRE feature, not just the last commit
4. Reference the requirement being closed

### Example

```text
Merge branch 'feature/REQ-042' into main

[REQ-042] Merged: User authentication API endpoints

What was merged:
- Implemented /api/auth/login and /api/auth/logout routes
- Added JWT token generation and validation
- Wrote 15 integration tests with 100% coverage
- Documented API endpoints in README.md

 Generated with Claude Code
```

## Release Commits

Special commits for version releases.

### Format

```text
[RELEASE] v1.2.0: Release description

What was released:
- Feature 1 (REQ-XXX)
- Feature 2 (REQ-YYY)
- Bug fix 1 (REQ-ZZZ)

 Generated with Claude Code
```

### Rules

1. Use `[RELEASE]` instead of REQ-XXX
2. Follow semantic versioning (major.minor.patch)
3. List ALL requirements included in release
4. Tag commit with version number
5. Update CHANGELOG.md in same commit

## Pre-Commit Hook Integration

If pre-commit hooks modify files, handle carefully.

### Scenario

1. You create commit with changes
2. Pre-commit hook runs linter/formatter
3. Hook modifies files (auto-format)
4. Commit needs updating

### Solution

```bash
# After pre-commit hook modifies files:
git add -u                    # Stage the auto-formatted changes
git commit --amend --no-edit  # Update the commit with formatted files
```

### Rules

1. ONLY amend if commit is NOT pushed
2. Verify amend doesn't overwrite someone else's work
3. Check `git log -1 --format='%an %ae'` to confirm authorship
4. Never use `--amend` on shared branches without team agreement

## CI/CD Integration

Commits trigger automated pipelines - be aware of special keywords.

### CI Trigger Keywords

Some CI systems watch for keywords in commit messages:

- `[skip ci]` - Skip CI pipeline (use sparingly)
- `[ci skip]` - Alternative syntax
- `[no ci]` - Another alternative

### Example: Skip CI for Docs

```text
[REQ-115] Docs: Update API documentation [skip ci]

What was done:
- Fixed typos in README.md
- Updated API endpoint examples
- Added troubleshooting section

 Generated with Claude Code
```

### Rules

1. Only skip CI for documentation-only changes
2. NEVER skip CI for code changes
3. NEVER skip CI for dependency updates
4. Use `[skip ci]` at END of header line

## Handling Mistakes

If you committed the wrong thing:

### Before Pushing

```bash
# Undo last commit, keep changes
git reset --soft HEAD~1

# Undo last commit, discard changes (DANGEROUS)
git reset --hard HEAD~1

# Amend commit message
git commit --amend
```

### After Pushing

```bash
# Create a revert commit (safe)
git revert HEAD

# Force push (DANGEROUS - coordinate with team)
git push --force
```

### Rules

1. NEVER force push to main/master
2. NEVER rewrite shared history without team agreement
3. Prefer `git revert` over `git reset` after pushing
4. Communicate with team before any destructive operations
